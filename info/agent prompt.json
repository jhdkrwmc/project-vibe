You are operating IDA Pro via MCP on an 8051/8032-based Sonix SN9C292B camera firmware (128 KiB image). Mission: produce a robust, minimal patch that guarantees OSD is OFF on every cold boot, while keeping USB enumeration and normal operation intact. Any code edit MUST pass the firmware’s integrity gate (sum-based), so compute and apply a compensating fix before write-back.

=== Ground truth (from our reverse engineering) ===
• OSD control lives in XDATA at 0xE24–0xE27. A helper at 0xBB73 does:
  MOV DPTR,#0xE24; MOV A,#0xFF; MOVX @DPTR,A; INC DPTR; RET
  Other OSD updates hit 0xE27 via a sibling at ~0xBB63. OSD handlers cluster in 0xADBE–0xAE74. 
• Early boot/reset code does NOT write 0xE24–0xE27. OSD appears default-on (HW/ROM). We must either:
  A) inject an early call to turn OSD off post-boot, or
  B) no-op the runtime OSD writers (in 0xADxx/0xBB6x family),
  then correct the integrity sum.
• Integrity unit around 0xF01A references a data block around 0x09CE and traps to an SJMP $ loop at 0xF018 on mismatch.
• Main command dispatch: computed jump *JMP @A+DPTR* with DPTR base 0x1073; entries mix inline code, calls, and short jumps.

=== Success criteria ===
1) Verified: still no boot-time writes to 0xE24–0xE27.
2) Proposed patch site executes exactly once at boot, after integrity passes, before video starts.
3) OSD OFF behavior persists across cold power cycles.
4) USB enumerates cleanly (no Code 10). 
5) Checksum/sum is adjusted and validated on the final image.

=== MCP/IDA hygiene (always follow) ===
• Work in small, deterministic batches; keep windows 64–256 bytes; return both disasm and raw bytes for each claim.
• Prefer bytes to symbols: use find_binary on opcodes: 
  - 73                 // JMP @A+DPTR
  - 93                 // MOVC A,@A+DPTR
  - 90 0E              // MOV DPTR,#0x0E??
  - E0 A3 E0 A3        // MOVX reads walk
  - F0 A3 F0 A3        // MOVX writes walk
  - 80 FE              // SJMP $
• Always compute the 16-bit total sum pre/post edit and provide the compensator delta. For two’s-complement zero-sum, adjust a 2-byte pad so the total == 0x0000.

=== Exact MCP command packs to run ===

1) OSD writers & xrefs (prove boot-time absence; catalog handlers)
[
  {"id":"osd_e24_hits","command":"find_binary","params":{"start":"0x0000","end":"0x1FFFF","bytes":"90 0E 24"}},
  {"id":"osd_e27_hits","command":"find_binary","params":{"start":"0x0000","end":"0x1FFFF","bytes":"90 0E 27"}}
]
For each hit: return 128B disasm and 32B hex around the hit, plus xrefs_to for the basic block/function.

2) Reset reachability & early init survey (confirm no boot write to 0xE24–0xE27)
[
  {"id":"reset_dis","command":"disassemble_function","params":{"address":"0x0000"}},
  {"id":"scan_lcalls_0_400","command":"find_binary","params":{"start":"0x0000","end":"0x03FF","bytes":"12 ?? ??"}},

  {"id":"aa04","command":"disassemble_function","params":{"address":"0xAA04"}},
  {"id":"aa2b","command":"disassemble_function","params":{"address":"0xAA2B"}},
  {"id":"aa3a","command":"disassemble_function","params":{"address":"0xAA3A"}},
  {"id":"b88a","command":"disassemble_function","params":{"address":"0xB88A"}},
  {"id":"b930","command":"disassemble_function","params":{"address":"0xB930"}},
  {"id":"b932","command":"disassemble_function","params":{"address":"0xB932"}},
  {"id":"c56a","command":"disassemble_function","params":{"address":"0xC56A"}},
  {"id":"c632","command":"disassemble_function","params":{"address":"0xC632"}},
  {"id":"c63c","command":"disassemble_function","params":{"address":"0xC63C"}},
  {"id":"c641","command":"disassemble_function","params":{"address":"0xC641"}},
  {"id":"c646","command":"disassemble_function","params":{"address":"0xC646"}}
]
Return: any MOV DPTR,#0xE2? seen in these paths; otherwise evidence they don’t touch 0xE24–0xE27.

3) Integrity/sinks mapping (know where NOT to land)
[
  {"id":"scan_sjmp_hold","command":"find_binary","params":{"start":"0x0000","end":"0x1FFFF","bytes":"80 FE"}},   // SJMP $
  {"id":"jump_index","command":"run_python","params":{"code":"import idautils, ida_xref, ida_bytes, ida_ua, idaapi\nSINKS={0x29D8,0x3362,0xF018,0xF57B}\nres={s:[] for s in SINKS}\nfor ea in idautils.Heads():\n ins=ida_ua.insn_t();\n if ida_ua.decode_insn(ins,ea):\n  for i in range(2):\n   t=idaapi.calc_branch_target(ea,i)\n   if t in SINKS: res[t].append(ea)\nfor t,srcs in res.items():\n print('sink 0x%04X <- '%t + ', '.join('0x%04X'%s for s in srcs))"}} 
]
Return the sources hitting 0xF018 specifically (integrity fail path).

4) Decode the 0x1073 branch island (map command → action → target)
[
  {"id":"decode_1073","command":"run_python","params":{"code":"import ida_ua, ida_bytes\nbase=0x1073; span=0x100\nprint('idx,ea,b0 b1 b2,dec')\nfor off in range(span):\n ea=base+off\n b0=ida_bytes.get_byte(ea); b1=ida_bytes.get_byte(ea+1); b2=ida_bytes.get_byte(ea+2)\n dec='.'\n if b0==0x02: dec='LJMP 0x%04X'%((b1<<8)|b2)\n elif b0==0x80: rel=b1-256 if b1&0x80 else b1; dec='SJMP 0x%04X'%(ea+2+rel)\n elif b0 in (0x12,0x01): dec='CALL/JMP 0x%04X'%((b1<<8)|b2)\n print('%02X,0x%04X,%02X %02X %02X,%s'%(off,ea,b0,b1,b2,dec))"}}
]
Deliver a CSV and highlight entries that eventually touch OSD handlers or integrity code.

5) XDATA write atlas (who writes 0xE00–0xEFF)
[
  {"id":"xdata_atlas","command":"run_python","params":{"code":"import ida_bytes, idaapi\nfrom collections import defaultdict\nRES=defaultdict(list)\nSIZE=idaapi.get_image_size()\nea=0\nwhile ea<SIZE:\n  if ida_bytes.get_byte(ea)==0x90 and ea+2<SIZE:\n    lo=ida_bytes.get_byte(ea+1); hi=ida_bytes.get_byte(ea+2); base=(hi<<8)|lo\n    x=ea+3; lim=min(SIZE,ea+3+96); writes=0\n    while x<lim:\n      b=ida_bytes.get_byte(x)\n      if b==0xF0: writes+=1\n      elif b==0xA3 or b in (0x74,0x75,0xE4,0x90): pass\n      else: break\n      x+=1\n    if writes: RES[base].append((ea,writes))\n  ea+=1\nprint('base -> writers(count)')\nfor k in sorted(RES.keys()):\n  if 0x0E00<=k<=0x0EFF or any(n>=3 for _,n in RES[k]):\n    print('0x%04X:'%k, ', '.join('(0x%04X,%d)'%(ea,n) for ea,n in RES[k]))"}}]
Return the list for 0x0E24..0x0E27 in particular, with writers and their counts.

6) Sum check helper (before any patch trial)
[
  {"id":"sum16_all","command":"run_python","params":{"code":"import idaapi, ida_bytes\nSIZE=idaapi.get_image_size(); s=0\nfor ea in range(SIZE): s=(s+ida_bytes.get_byte(ea))&0xFFFF\nprint('SUM16(all)=0x%04X'%s)"}}
]
Return SUM16(all) now, and again after patch. Provide the 2-byte compensator write (address + new word) to zero the total (two’s complement).

=== Patch approach (propose two, pick the smaller change that meets criteria) ===
Option A (preferred, minimal risk): Guaranteed OSD-OFF post-boot via tiny injection.
• Identify a single-run, early-after-integrity path (e.g., first “main” init after 0xF01A sets success flags). 
• Inject three bytes: LCALL 0xBB73 (12 BB 73) to force OSD byte at 0xE24 to 0xFF at boot. If needed, follow with a minimal write to 0xE27 via its helper or inline “MOV DPTR,#0x0E27; CLR A; MOVX @DPTR,A”.
• Do NOT place in sensitive regions (avoid 0x1400–0x14FF). Prefer an existing 3+ byte no-op gap, a cold path pad, or a replaceable AJMP/LCALL that we re-point with identical length.
• Recompute sum and apply 2-byte compensator (footer or a safe pad inside the summed range). Validate device boots and OSD is off on cold power.

Option B (runtime handler neuter): No-op the OSD writers.
• In the 0xADBE..0xAE74 cluster and/or the leaf helper(s), replace “MOVX @DPTR,A” (0xF0) with NOP (0x00) where the destination DPTR == 0x0E24..0x0E27. Keep it surgical: only instances that target these bases.
• Recompute and fix the sum. Validate.

=== Deliverables ===
• Evidence pack: for every claim, include 64–128B disasm and 16–32B hexdump; full decode CSV of 0x1073 island; caller lists into SJMP $ sinks; full list of 0xE24..0xE27 writers + xrefs.
• A patch diff (addresses + old/new bytes), the compensator write, and a scriptable patch step.
• A boot validation note: USB VID/PID enumeration log and OSD state photo/frame or UVC control readback.

=== Do-not-do ===
• Don’t patch without a sum fix.
• Don’t place edits in 0x1400–0x14FF or near USB init tables unless proven safe.
• Don’t rely on any hidden TLV default for OSD—there isn’t one.
